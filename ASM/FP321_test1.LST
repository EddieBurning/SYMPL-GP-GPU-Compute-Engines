 00000000                                  CPU  "aSYMPL32.TBL"
 00000000                                  HOF  "MOT32"
 00000000                                  WDLN 4
                                ; FP321-AXI4 test1
                                ; version 1.03   Sept 17, 2015
                                ; Author:  Jerry D. Harthcock
                                ; Copyright (C) 2015.  All rights reserved without prejudice.
                                           
                                ;--------------------------------------------------------------------------           
                                ;         internal memory-mapped h/w registers
                                ;--------------------------------------------------------------------------
 00000073         =             AR3:        EQU     0x73                    ;Auxiliary Reg 3
 00000072         =             AR2:        EQU     0x72                    ;Auxiliary Reg 2
 00000071         =             AR1:        EQU     0x71                    ;Auxiliary Reg 1
 00000070         =             AR0:        EQU     0x70                    ;Auxiliary Reg 0
 0000006F         =             PC:         EQU     0x6F                    ;Program Counter
 0000006E         =             PC_COPY:    EQU     0x6E
 0000006D         =             STATUS:     EQU     0x6D                    ;Statis Register
 0000006C         =             SCHED:      EQU     0x6C                    ;scheduler
 0000006B         =             SCHEDCMP:   EQU     0x6B                    ;scheduler max count values
 0000006A         =             C_reg:      EQU     0x6A                    ;FMA C register
 00000069         =             LPCNT1:     EQU	    0x69		   	        ;dedicated loop counter 1 
 00000068         =             LPCNT0:	    EQU	    0x68 			        ;dedicated loop counter 0
 00000067         =             TIMER:      EQU     0x67                    ;timer
 00000066         =             QOS:        EQU     0x66                    ;quality of service exception counters
 00000065         =             DOT:        EQU     0x65                    ;DOT operator
 00000064         =             RPT:        EQU     0x64                    ;repeat counter location
 00000063         =             CAPTURE3:   EQU     0x63                    ;alternate delayed exception capture register 3
 00000062         =             CAPTURE2:   EQU     0x62                    ;alternate delayed exception capture register 2
 00000061         =             CAPTURE1:   EQU     0x61                    ;alternate delayed exception capture register 1
 00000060         =             CAPTURE0:   EQU     0x60                    ;alternate delayed exception capture register 0
                                
                                ;zero-page storage
 00000001         =             NMI_save    EQU     0x01                    ;save PC_COPY here immediately upon entry to NMI service routine
 00000002         =             INV_save    EQU     0x02                    ;invalid exception PC_COPY save location
 00000003         =             DIVx0_save  EQU     0x03                    ;divide by 0 exception PC_COPY save location
 00000004         =             OVFL_save   EQU     0x04                    ;overflow exception PC_COPY save location
 00000005         =             UNFL_save   EQU     0x05                    ;underflow exception PC_COPY save location
 00000006         =             INEX_save   EQU     0x06                    ;inexact exception PC_COPY save location
 00000007         =             IRQ_PC_save EQU     0x07                    ;save PC_COPY here immediately upon entry to general-purpose IRQ service routine
 00000008         =             FGS_save:   EQU     0x08                    ;location for saving original Fine-Grain scheduler
 00000014         =             work_1:     EQU     0x14                    
 00000015         =             work_2:     EQU     0x15
 00000016         =             work_3:     EQU     0x16
 00000017         =             work_4:     EQU     0x17
 00000018         =             work_5:     EQU     0x18
 00000019         =             work_6:     EQU     0x19
 0000001A         =             capt0_save: EQU     0x1A                    ;alternate delayed exception capture register 0 save location
 0000001B         =             capt1_save: EQU     0x1B                    ;alternate delayed exception capture register 1 save location
 0000001C         =             capt2_save: EQU     0x1C                    ;alternate delayed exception capture register 2 save location
 0000001D         =             capt3_save: EQU     0x1D                    ;alternate delayed exception capture register 3 save location
 0000001E         =             lst_len:    EQU     0x1E                    ;length of list goes here
 00000020         =             constA:     EQU     0x20                    ;constant A goes here
 00000021         =             constB:     EQU     0x21                    ;constant B goes here
 00000022         =             constC:     EQU     0x22                    ;constant C goes here
                                
 00000800         =             packet:     EQU     0x0800                  ;start location of the data packet to be processed
                                
                                ;constant immediate value equates
 00000020         =             DONE_BIT:   EQU     0x20                    ;bit [5] is DONE Bit in status register
                                
                                     
                                ;this thread first loads all FP operators with some arbitrary value followed by a read of the resutls
                                ;then performs the following integer calculation on each 32-bit entry in the submitted list and written back over the submitted value
                                ; result = AX^2 + BX + C    
                                  
                                            
 000000FD                                   org     0x0FD              
                                
 000000FD 0000010E              Constants:  DFL     start                   ;program memory locations 0x000 - 0x0FF reserved for look-up table
                                        
 000000FE 00000054              prog_len:   DFL     progend - Constants
 000000FF 40490FD0              pi:         DFF     3.14159
                                              
                                ;           func    dest, srcA, srcB 
                                
 00000100                                   org     0x00000100
 00000100 306F0108              RST_VECT:   mov     PC, #done               ;reset vector
 00000101 306F0137              NMI_VECT:   mov     PC, #NMI_               ;NMI vector
 00000102 306F013A              INV_VECT:   mov     PC, #INV_               ;invalid operation exception vector location
 00000103 306F013E              DIVx0_VECT: mov     PC, #DIVx0_             ;divide by 0 exception vector location
 00000104 306F0145              OVFL_VECT:  mov     PC, #OVFL_              ;overflow exception vector location
 00000105 306F0148              UNFL_VECT:  mov     PC, #UNFL_              ;underflow exception vector location
 00000106 306F014B              INEXT_VECT: mov     PC, #INEXT_             ;inexact exception vector location
 00000107 306F014E              IRQ_VECT:   mov     PC, #IRQ_               ;maskable general-purpose interrupt vector
                                
 00000108 30730800              done:       mov     AR3, #packet            ;point to start of packet which is both a semaphor and entry point for thread
 00000109 126D6D20              semphr:     or      STATUS, STATUS, #DONE_BIT   ; signal external CPU (load-balancer/coarse-grain scheduler) process is done
                                                                            ;note that the DONE_BIT is already set upon initial entry but is cleared three instruction below "start"
                                                                            ;to signal CPU thread has started (ie, not done)        
 0000010A 12147700              spin:       or      work_1, *AR3, #0        ;see if first location (the semaphor and routine entry point) of packet is non-zero
                                                                            ;during this time the CPU is pushing packet into Shader memory and, as a final step,
                                                                            ;and will write the non-zero PC entry point to the location pointed to by AR3 when AXI4 DMA xfer is complete
 0000010B 04FF006D                          bcnd    spin, Z                 ;if semaphr is 0 then wait for this value to become non-zero in the packet RAM block
 0000010C 30770000                          mov     *AR3, #0                ;clear the semaphor now so we don't fall through again when we get done and come back here
 0000010D 006F1400                          mov     PC, work_1              ;else perform the specified thread pointed to by contents of work_1, in this case, "start"
                                        
 0000010E                       start:  
 0000010E 3067001E                          mov     TIMER, #30              ;load time-out timer with small value to induce timeout NMI before completion (for testing/simulation purposes)
 0000010F 30730801                          mov     AR3, #packet + 1        ;load AR3 with pointer to list length in parameter/data packet just received                                 
 00000110 116D6DDF                          and     STATUS, STATUS, #0xDF   ;clear the DONE bit
 00000111 00687B00                          mov     LPCNT0, *AR3++          ;copy list length into hardware loop counter LPCNT0 
 00000112 00207B00                          mov     constA, *AR3++          ;copy constA from packet
 00000113 00217B00                          mov     constB, *AR3++          ;copy constB
 00000114 00227B00                          mov     constC, *AR3++          ;copy constC, after which, AR3 should now be pointing at the 1st element in the list
                                        
 00000115 30192180              inv_test:   mov     work_6, #0x2180         ;mask for status register to enable alternate delayed exception handling for divide by 0 and
 00000116 056D1903                          shft    STATUS, work_6, LEFT, 4 ;alternate immedate exception handling for invalid operation respectively
 00000117 30197FBF                          mov     work_6, #0x7FBF         ;create "signaling" NaN to test invalid operation using SQRT operator
 00000118 0519190F                          shft    work_6, work_6, LEFT, 16 ;note that a table-read of a 32-bit constant can be used in lieu of this
 00000119 00D11900                          mov     SQRT_1, work_6          ;write signaling NaN to SQRT_1 to induce alternate-immediate-invalid operation exception
 0000011A 10C22200              divx0_test: mov     FDIV_2,  constC, #0     ; setup for divide by 0 alternate-delayed-exception. Note that, for alternate-dealyed exception,
                                                                            ; the results must be read before the interrupt will be generated                
                                               
 0000011B 0A147777              loop:       mul     work_1, *AR3, *AR3      ;square X
 0000011C 0A141420                          mul     work_1, work_1, constA  ;multiply X^2 * constA
 0000011D 0A157721                          mul     work_2, *AR3, constB    ;multiply X * constB
 0000011E 06161415                          add     work_3, work_1, work_2  ;add AX^2 + BX
 0000011F 067B1622                          add     *AR3++, work_3, constC  ;get final answer and write back over original value X
 00000120 04FB0F68                          dbnz    loop, LPCNT0            ;decrement dedicated hardware loop counter 0 and, if not zero, then do next value in the list
                                                                            ;note that dbnz is an alias of BTBS, with bit 15 of LPCNT0 being tested for "1" condition (ie, Zero)
                                                                            ;also note that LPCNT0 and LPCNT1 h/w decrement counters are actually only 13-bits wide, allowing their dedicated
                                                                            ;Zero flags to occupy bit 15 at the same address when read by the alias BTBS instruction, DBNZ
 00000121 0019C200              divx0_cont: mov     work_6, FDIV_2          ;now that the previous FDIV_2 operation has had time to complete, read result buffer to induce
                                                                            ;the corresponding div by 0 alternate delayed exception handler
                                ;the following instructins don't really anthing useful except for exercising the floating-point operators for test/simulation purposes
 00000122 30B60002                          mov     ITOF_6, #2              ;convert integer 2 to float 2.0
 00000123 2018FF00                          mov     work_5, @pi             ;read pi out of ROM and store it in direct memory work_5
 00000124 0017B600                          mov     work_4, ITOF_6          ;move result of ITOF to directly addressable RAM location work_4
 00000125 00C41817                          mov     FDIV_4, work_5, work_4  ;FDIV pi by 2.0
                                ;sema:       btbc    sema, 5, FDIV_4         ;test semaphor bit for FDIV_4 (bit 5) and try again if cleared (for H/W simulation purposes in this instance)
                                                                            ;note that the above btbc instruction is superfluous because a MOV read operation from
                                                                            ;any float operator address will rewind the PC automatically if the ready semaphor for that
                                                                            ;operator location is not set (ie, not ready).  Technically speaking, the instruction pipeline never stalls, because
                                                                            ;no opcode ever consumes more than one clock regardless of the state of a given FP operator semaphor, because
                                                                            ; the PC is automatically rewound to re-fetch if not ready
                                
 00000126 00F11700                          mov     LOG_1,  work_4          ;get the log of 2.0
 00000127 2082FF17                          mov     FADD_2, @pi, work_4     ;FADD pi + 2.0   (FADD_2, work_4, work_4 will yeild the same result)
 00000128 00971817                          mov     FSUB_7, work_5, work_4  ;FSUB 2 from pi
 00000129 00A91717                          mov     FMUL_9, work_4, work_4  ;get the square of 2.0
 0000012A 00651717                          mov     DOT, work_4, work_4     ;square 2 
 0000012B 206AFF00                          mov     C_reg, @pi
 0000012C 00E31717                          mov     FMA_3, work_4, work_4
 0000012D 00FBF100                          mov     EXP_3, LOG_1            ;convert log of 2.0 back to 2.0
 0000012E 00651717                          mov     DOT, work_4, work_4
 0000012F 00D8A900                          mov     SQRT_8, FMUL_9          ;get the SQRT of 4.0
 00000130 007BC400                          mov     *AR3++, FDIV_4          ;read out reslts from FDIV_4 and store in next location in parameter/data buffer
 00000131 007B8200                          mov     *AR3++, FADD_2          ;same for FADD_2 (should be 5.14159)
 00000132 007BFB00                          mov     *AR3++, EXP_3           ;same for EXP_3 (should be 2.0)
 00000133 007B9700                          mov     *AR3++, FSUB_7          ;same for FSUB_7 (should be 1.14149)
 00000134 00BDD800                          mov     FTOI_5, SQRT_8          ;read out results from SQRT_8 and convert to integer (results should be 2)
 00000135 00186500                          mov     work_5, DOT
                                                                            
 00000136 306F0108                          mov     PC, #done               ;jump to done, semphr test and spin for next packet
                                ; interrupt service routines        
 00000137 00016E00              NMI_:       mov     NMI_save, PC_COPY       ;save return address from non-maskable interrupt (time-out timer in this instance)
 00000138 30672710                          mov     TIMER, #10000           ;put a new value in the timer
 00000139 006F0100                          mov     PC, NMI_save            ;return from interrupt
                                        
 0000013A 00026E00              INV_:       mov     INV_save, PC_COPY       ;save return address from floating-point invalid operation exception, which is maskable
 0000013B 30672710                          mov     TIMER, #10000           ;put a new value in the timer
 0000013C 0019D100                          mov     work_6, SQRT_1          ;retrieve the NaN with payload (this quiet NaN replaced the signaling NaN that caused the INV exc)
 0000013D 006F0200                          mov     PC, INV_save            ;return from interrupt
                                            
 0000013E 00036E00              DIVx0_:     mov     DIVx0_save, PC_COPY     ;save return address from floating-point divide by 0 exception, which is maskable
 0000013F 001A6000                          mov     capt0_save, CAPTURE0    ;read out CAPTURE0 register and save it
 00000140 001B6100                          mov     capt1_save, CAPTURE1    ;read out CAPTURE1 register and save it
 00000141 001C6200                          mov     capt2_save, CAPTURE2    ;read out CAPTURE2 register and save it
 00000142 001D6300                          mov     capt3_save, CAPTURE3    ;read out CAPTURE3 register and save it
 00000143 30672710                          mov     TIMER, #10000           ;put a new value in the timer
 00000144 006F0300                          mov     PC, DIVx0_save          ;return from interrupt
                                
 00000145 00046E00              OVFL_:      mov     OVFL_save, PC_COPY      ;save return address from floating-point overflow exception, which is maskable
 00000146 30672710                          mov     TIMER, #10000           ;put a new value in the timer
 00000147 006F0400                          mov     PC, OVFL_save           ;return from interrupt
                                
 00000148 00056E00              UNFL_:      mov     UNFL_save, PC_COPY      ;save return address from floating-point underflow exception, which is maskable
 00000149 30672710                          mov     TIMER, #10000           ;put a new value in the timer
 0000014A 006F0500                          mov     PC, UNFL_save           ;return from interrupt
                                
 0000014B 00066E00              INEXT_:     mov     INEX_save, PC_COPY      ;save return address from floating-point inexact exception, which is maskable
 0000014C 30672710                          mov     TIMER, #10000           ;put a new value in the timer
 0000014D 006F0600                          mov     PC, INEX_save           ;return from interrupt
                                
 0000014E 00076E00              IRQ_:       mov     IRQ_PC_save, PC_COPY    ;save return address (general-purpose, maskable interrupt)
 0000014F 30672710                          mov     TIMER, #10000           ;put a new value in the timer
 00000150 006F0700                          mov     PC, IRQ_PC_save         ;return from interrupt            
 00000151                       progend:        
 00000000                                   end
00000070  AR0                00000071  AR1                00000072  AR2                
00000073  AR3                0000001A  CAPT0_SAVE         0000001B  CAPT1_SAVE         
0000001C  CAPT2_SAVE         0000001D  CAPT3_SAVE         00000060  CAPTURE0           
00000061  CAPTURE1           00000062  CAPTURE2           00000063  CAPTURE3           
00000020  CONSTA             000000FD  CONSTANTS          00000021  CONSTB             
00000022  CONSTC             0000006A  C_REG              0000013E  DIVX0_             
00000121  DIVX0_CONT         00000003  DIVX0_SAVE         0000011A  DIVX0_TEST         
00000103  DIVX0_VECT         00000108  DONE               00000020  DONE_BIT           
00000065  DOT                000000F8  EXP_0              000000F9  EXP_1              
000000FA  EXP_2              000000FB  EXP_3              000000FC  EXP_4              
000000FD  EXP_5              000000FE  EXP_6              000000FF  EXP_7              
00000080  FADD_0             00000081  FADD_1             00000082  FADD_2             
00000083  FADD_3             00000084  FADD_4             00000085  FADD_5             
00000086  FADD_6             00000087  FADD_7             00000088  FADD_8             
00000089  FADD_9             0000008A  FADD_A             0000008B  FADD_B             
0000008C  FADD_C             0000008D  FADD_D             0000008E  FADD_E             
0000008F  FADD_F             000000C0  FDIV_0             000000C1  FDIV_1             
000000C2  FDIV_2             000000C3  FDIV_3             000000C4  FDIV_4             
000000C5  FDIV_5             000000C6  FDIV_6             000000C7  FDIV_7             
000000C8  FDIV_8             000000C9  FDIV_9             000000CA  FDIV_A             
000000CB  FDIV_B             000000CC  FDIV_C             000000CD  FDIV_D             
000000CE  FDIV_E             000000CF  FDIV_F             00000008  FGS_SAVE           
000000E0  FMA_0              000000E1  FMA_1              000000E2  FMA_2              
000000E3  FMA_3              000000E4  FMA_4              000000E5  FMA_5              
000000E6  FMA_6              000000E7  FMA_7              000000E8  FMA_8              
000000E9  FMA_9              000000EA  FMA_A              000000EB  FMA_B              
000000EC  FMA_C              000000ED  FMA_D              000000EE  FMA_E              
000000EF  FMA_F              000000A0  FMUL_0             000000A1  FMUL_1             
000000A2  FMUL_2             000000A3  FMUL_3             000000A4  FMUL_4             
000000A5  FMUL_5             000000A6  FMUL_6             000000A7  FMUL_7             
000000A8  FMUL_8             000000A9  FMUL_9             000000AA  FMUL_A             
000000AB  FMUL_B             000000AC  FMUL_C             000000AD  FMUL_D             
000000AE  FMUL_E             000000AF  FMUL_F             00000090  FSUB_0             
00000091  FSUB_1             00000092  FSUB_2             00000093  FSUB_3             
00000094  FSUB_4             00000095  FSUB_5             00000096  FSUB_6             
00000097  FSUB_7             00000098  FSUB_8             00000099  FSUB_9             
0000009A  FSUB_A             0000009B  FSUB_B             0000009C  FSUB_C             
0000009D  FSUB_D             0000009E  FSUB_E             0000009F  FSUB_F             
000000B8  FTOI_0             000000B9  FTOI_1             000000BA  FTOI_2             
000000BB  FTOI_3             000000BC  FTOI_4             000000BD  FTOI_5             
000000BE  FTOI_6             000000BF  FTOI_7             0000014B  INEXT_             
00000106  INEXT_VECT         00000006  INEX_SAVE          0000013A  INV_               
00000002  INV_SAVE           00000115  INV_TEST           00000102  INV_VECT           
0000014E  IRQ_               00000007  IRQ_PC_SAVE        00000107  IRQ_VECT           
000000B0  ITOF_0             000000B1  ITOF_1             000000B2  ITOF_2             
000000B3  ITOF_3             000000B4  ITOF_4             000000B5  ITOF_5             
000000B6  ITOF_6             000000B7  ITOF_7             000000F0  LOG_0              
000000F1  LOG_1              000000F2  LOG_2              000000F3  LOG_3              
000000F4  LOG_4              000000F5  LOG_5              000000F6  LOG_6              
000000F7  LOG_7              0000011B  LOOP               00000068  LPCNT0             
00000069  LPCNT1             0000001E  LST_LEN            00000137  NMI_               
00000001  NMI_SAVE           00000101  NMI_VECT           00000145  OVFL_              
00000004  OVFL_SAVE          00000104  OVFL_VECT          00000800  PACKET             
0000006F  PC                 0000006E  PC_COPY            000000FF  PI                 
00000151  PROGEND            000000FE  PROG_LEN           00000066  QOS                
00000064  RPT                00000100  RST_VECT           0000006C  SCHED              
0000006B  SCHEDCMP           00000109  SEMPHR             0000010A  SPIN               
000000D0  SQRT_0             000000D1  SQRT_1             000000D2  SQRT_2             
000000D3  SQRT_3             000000D4  SQRT_4             000000D5  SQRT_5             
000000D6  SQRT_6             000000D7  SQRT_7             000000D8  SQRT_8             
000000D9  SQRT_9             000000DA  SQRT_A             000000DB  SQRT_B             
000000DC  SQRT_C             000000DD  SQRT_D             000000DE  SQRT_E             
000000DF  SQRT_F             0000010E  START              0000006D  STATUS             
00000067  TIMER              00000148  UNFL_              00000005  UNFL_SAVE          
00000105  UNFL_VECT          00000014  WORK_1             00000015  WORK_2             
00000016  WORK_3             00000017  WORK_4             00000018  WORK_5             
00000019  WORK_6             
